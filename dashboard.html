<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CDN Analytics</title>
  <style>
    :root {
      --primary: #eb1000;
      --primary-dark: #c40d00;
      --bg: #f9fafb;
      --card-bg: #ffffff;
      --text: #1d2939;
      --text-secondary: #667085;
      --border: #e4e7ec;
      --success: #12b76a;
      --error: #f04438;
      --chart-line: #eb1000;
      --bar-bg: #fce4e4;
      --status-ok: #12b76a;
      --status-client-error: #f79009;
      --status-server-error: #f04438;
      --input-bg: #ffffff;
      --filter-tag-bg: #e8f4fd;
      --filter-tag-border: #b8daff;
      --filter-tag-color: #004085;
      --grid-line: #f2f4f7;
      --axis-line: #e4e7ec;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --primary: #ff4136;
        --primary-dark: #ff6b63;
        --bg: #0d1117;
        --card-bg: #161b22;
        --text: #e6edf3;
        --text-secondary: #8b949e;
        --border: #30363d;
        --success: #3fb950;
        --error: #f85149;
        --chart-line: #ff4136;
        --bar-bg: #3d1a1a;
        --status-ok: #3fb950;
        --status-client-error: #d29922;
        --status-server-error: #f85149;
        --input-bg: #0d1117;
        --filter-tag-bg: #1f3a5f;
        --filter-tag-border: #388bfd;
        --filter-tag-color: #79c0ff;
        --grid-line: #21262d;
        --axis-line: #30363d;
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }

    /* Login Form */
    #login {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    #login.hidden { display: none; }

    .login-card {
      background: var(--card-bg);
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      padding: 40px;
      width: 100%;
      max-width: 400px;
    }

    .login-card h1 {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .login-card p {
      color: var(--text-secondary);
      margin-bottom: 24px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 6px;
    }

    .form-group input {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      background: var(--input-bg);
      color: var(--text);
    }

    .form-group input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(235, 16, 0, 0.15);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: background 0.2s;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
      width: 100%;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-secondary {
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--bg);
    }

    .error-message {
      background: var(--bar-bg);
      border: 1px solid var(--error);
      color: var(--error);
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 14px;
      display: none;
    }

    .error-message.visible { display: block; }

    /* Dashboard */
    #dashboard {
      display: none;
      min-height: 100vh;
    }

    #dashboard.visible { display: block; }

    /* Header */
    header {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    header h1 {
      font-size: 20px;
      margin-right: auto;
    }

    .query-timer {
      font-size: 12px;
      font-weight: normal;
      color: var(--text-secondary);
      margin-left: 8px;
    }

    .query-timer.fast {
      color: var(--status-ok);
    }

    .query-timer.medium {
      color: var(--status-client-error);
    }

    .query-timer.slow {
      color: var(--status-server-error);
    }

    header select,
    header input[type="text"] {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 14px;
      background: var(--input-bg);
      color: var(--text);
    }

    header input[type="text"] {
      width: 250px;
    }

    header select option {
      background: var(--card-bg);
      color: var(--text);
    }

    #activeFilters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: var(--filter-tag-bg);
      border: 1px solid var(--filter-tag-border);
      border-radius: 4px;
      font-size: 12px;
      color: var(--filter-tag-color);
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .filter-tag.exclude {
      background: var(--bar-bg);
      border-color: var(--error);
      color: var(--error);
    }

    .filter-tag button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0;
      color: inherit;
      opacity: 0.7;
    }

    .filter-tag button:hover {
      opacity: 1;
    }

    /* Main Content */
    main {
      padding: 24px;
    }

    /* Chart Section */
    .chart-section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid var(--border);
      margin-bottom: 24px;
    }

    .chart-container {
      position: relative;
      height: 250px;
    }

    #chart {
      width: 100%;
      height: 100%;
    }

    .chart-section h2 {
      font-size: 16px;
      margin-bottom: 16px;
    }

    /* Breakdown Tables */
    .breakdowns {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
    }

    @media (max-width: 1400px) {
      .breakdowns {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (max-width: 1000px) {
      .breakdowns {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 600px) {
      .breakdowns {
        grid-template-columns: 1fr;
      }
    }

    @media (min-width: 1800px) {
      .breakdowns {
        grid-template-columns: repeat(5, 1fr);
      }
    }

    @media (min-width: 2200px) {
      .breakdowns {
        grid-template-columns: repeat(6, 1fr);
      }
    }

    @media (min-width: 2600px) {
      .breakdowns {
        grid-template-columns: repeat(7, 1fr);
      }
    }

    .breakdown-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid var(--border);
      transition: filter 0.2s ease-out;
    }

    .breakdown-card.updating {
      filter: blur(2px);
      opacity: 0.7;
    }

    .breakdown-card h3 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .speed-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .speed-indicator.fast {
      background: var(--status-ok);
    }

    .speed-indicator.medium {
      background: var(--status-client-error);
    }

    .speed-indicator.slow {
      background: var(--status-server-error);
    }

    .speed-indicator.slowest {
      box-shadow: 0 0 6px 2px currentColor;
    }

    .speed-indicator.slowest.fast {
      box-shadow: 0 0 6px 2px var(--status-ok);
    }

    .speed-indicator.slowest.medium {
      box-shadow: 0 0 6px 2px var(--status-client-error);
    }

    .speed-indicator.slowest.slow {
      box-shadow: 0 0 6px 2px var(--status-server-error);
    }

    .clear-facet-btn {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text-secondary);
      cursor: pointer;
      font-weight: normal;
    }

    .clear-facet-btn:hover {
      background: var(--bg);
      color: var(--text);
    }

    .breakdown-table {
      width: 100%;
      font-size: 13px;
    }

    .breakdown-table tr {
      border-bottom: 1px solid var(--border);
    }

    .breakdown-table tr:last-child {
      border-bottom: none;
    }

    .breakdown-table tr.filter-included .dim {
      text-decoration: underline;
      text-decoration-color: var(--text);
      text-underline-offset: 3px;
    }

    .breakdown-table tr.filter-excluded .dim {
      text-decoration: underline;
      text-decoration-color: var(--error);
      text-underline-offset: 3px;
      opacity: 0.6;
    }

    .breakdown-table td {
      padding: 8px 0;
    }

    .breakdown-table .dim {
      max-width: 180px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .breakdown-table .dim a {
      color: var(--text);
      text-decoration: none;
    }

    .breakdown-table .dim a:hover {
      color: var(--primary);
      text-decoration: underline;
    }

    .breakdown-table .count {
      text-align: right;
      font-weight: 500;
      white-space: nowrap;
      padding-left: 8px;
      position: relative;
    }

    .breakdown-table .count .value {
      display: block;
    }

    .breakdown-table .count .action-btn {
      display: none;
      position: absolute;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
    }

    .breakdown-table tr:hover .count .value {
      display: none;
    }

    .breakdown-table tr:hover .count .action-btn {
      display: block;
    }

    .breakdown-table .bar {
      width: 60px;
      padding-left: 8px;
      position: relative;
    }

    .breakdown-table .bar-inner {
      height: 8px;
      background: var(--bar-bg);
      border-radius: 4px;
      overflow: hidden;
      display: flex;
    }

    .breakdown-table .bar .action-btn {
      display: none;
      position: absolute;
      top: 50%;
      left: 8px;
      transform: translateY(-50%);
    }

    .breakdown-table tr:hover .bar .bar-inner {
      display: none;
    }

    .breakdown-table tr:hover .bar .action-btn {
      display: block;
    }

    .breakdown-table .bar-segment {
      height: 100%;
    }

    .breakdown-table .bar-5xx {
      background: var(--status-server-error);
    }

    .breakdown-table .bar-4xx {
      background: var(--status-client-error);
    }

    .breakdown-table .bar-ok {
      background: var(--status-ok);
    }

    .breakdown-table .bar-fill {
      height: 100%;
      background: var(--primary);
      border-radius: 4px;
    }

    .breakdown-table .action-btn {
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--card-bg);
      cursor: pointer;
      color: var(--text);
      white-space: nowrap;
    }

    .breakdown-table .action-btn:hover {
      background: var(--bg);
    }

    .breakdown-table .action-btn.exclude {
      color: var(--error);
    }

    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 8px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Empty State */
    .empty {
      text-align: center;
      padding: 20px;
      color: var(--text-secondary);
      font-size: 13px;
    }

    /* Logs Button */
    .logs-btn {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 24px;
      font-size: 14px;
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
    }

    .logs-btn:hover {
      background: var(--bg);
    }

    .logs-btn.ready {
      border-color: var(--primary);
    }

    .logs-btn.active {
      background: var(--bg);
    }

    header {
      position: relative;
    }

    /* Logs View */
    #logsView {
      display: none;
      padding: 24px;
    }

    #logsView.visible {
      display: block;
    }

    #dashboardContent.hidden {
      display: none;
    }

    .logs-table-container {
      background: var(--card-bg);
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow-x: auto;
    }

    .logs-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    }

    .logs-table th {
      background: var(--bg);
      padding: 10px 12px;
      text-align: left;
      font-weight: 600;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      white-space: nowrap;
    }

    .logs-table td {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .logs-table tr:hover td {
      background: var(--bg);
    }

    .logs-table tr:last-child td {
      border-bottom: none;
    }

    .logs-table .status-ok {
      color: var(--status-ok);
    }

    .logs-table .status-4xx {
      color: var(--status-client-error);
    }

    .logs-table .status-5xx {
      color: var(--status-server-error);
    }

    .logs-table .timestamp {
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .logs-table .method {
      font-weight: 600;
    }

    .logs-table .url {
      max-width: 400px;
    }

    .logs-table .host {
      max-width: 200px;
    }

    .logs-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 60px;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <!-- Login Form -->
  <div id="login">
    <div class="login-card">
      <h1>CDN Analytics</h1>
      <p>Sign in to view your analytics dashboard</p>
      <div id="loginError" class="error-message"></div>
      <form id="loginForm">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text" id="username" name="username" required autocomplete="username">
        </div>
        <div class="form-group">
          <label for="password">Password</label>
          <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Sign In</button>
      </form>
    </div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard">
    <header>
      <h1>CDN Analytics <span id="queryTimer" class="query-timer"></span></h1>
      <button id="logsBtn" class="logs-btn">Logs</button>
      <select id="timeRange">
        <option value="1h" selected>Last hour</option>
        <option value="12h">Last 12 hours</option>
        <option value="24h">Last 24 hours</option>
        <option value="7d">Last 7 days</option>
      </select>
      <select id="topN">
        <option value="5" selected>Top 5</option>
        <option value="10">Top 10</option>
        <option value="20">Top 20</option>
        <option value="50">Top 50</option>
        <option value="100">Top 100</option>
      </select>
      <input type="text" id="hostFilter" placeholder="Filter by host...">
      <div id="activeFilters"></div>
      <button id="refreshBtn" class="btn btn-secondary">Refresh</button>
      <button id="logoutBtn" class="btn btn-secondary">Logout</button>
    </header>

    <!-- Logs View -->
    <div id="logsView">
      <div class="logs-table-container">
        <div class="logs-loading"><div class="spinner"></div>Loading logs...</div>
      </div>
    </div>

    <main id="dashboardContent">
      <!-- Time Series Chart -->
      <section class="chart-section">
        <h2>Requests over time</h2>
        <div class="chart-container">
          <canvas id="chart"></canvas>
        </div>
      </section>

      <!-- Breakdown Tables -->
      <section class="breakdowns" id="breakdowns">
        <div class="breakdown-card" id="breakdown-status-range">
          <h3>Status Range</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-hosts">
          <h3>Hosts</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-forwarded-hosts">
          <h3>Forwarded Hosts</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-content-types">
          <h3>Content Types</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-status">
          <h3>Status Codes</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-errors">
          <h3>Errors</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-cache">
          <h3>Cache Status</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-paths">
          <h3>Paths</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-referers">
          <h3>Referers</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-user-agents">
          <h3>User Agents</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-ips">
          <h3>IP Addresses</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-request-type">
          <h3>Request Types</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-backend-type">
          <h3>Backend Types</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-methods">
          <h3>HTTP Methods</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-datacenters">
          <h3>Datacenters</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
        <div class="breakdown-card" id="breakdown-asn">
          <h3>ASN</h3>
          <div class="loading"><div class="spinner"></div>Loading...</div>
        </div>
      </section>
    </main>
  </div>

  <script>
    // Configuration
    const CLICKHOUSE_URL = 'https://ogadftwx3q.us-east1.gcp.clickhouse.cloud:8443/';
    const DATABASE = 'helix_logs_production';
    const TABLE = 'cdn_requests_combined';

    // State
    const state = {
      credentials: null,
      timeRange: '1h',
      hostFilter: '',
      topN: 5,
      filters: [],    // [{col: '`request.url`', value: '/foo', exclude: false}]
      logsData: null,
      logsLoading: false,
      logsReady: false,
      showLogs: false,
    };

    // URL State Management
    function saveStateToURL() {
      const params = new URLSearchParams();

      if (state.timeRange !== '1h') params.set('t', state.timeRange);
      if (state.hostFilter) params.set('host', state.hostFilter);
      if (state.topN !== 5) params.set('n', state.topN);
      if (state.showLogs) params.set('view', 'logs');

      // Save query timestamp as ISO string
      if (queryTimestamp) {
        params.set('ts', queryTimestamp.toISOString());
      }

      // Encode filters as JSON array
      if (state.filters.length > 0) {
        params.set('filters', JSON.stringify(state.filters));
      }

      const newURL = params.toString()
        ? `${window.location.pathname}?${params}`
        : window.location.pathname;
      window.history.replaceState({}, '', newURL);
    }

    function loadStateFromURL() {
      const params = new URLSearchParams(window.location.search);

      if (params.has('t')) {
        const t = params.get('t');
        if (['1h', '12h', '24h', '7d'].includes(t)) {
          state.timeRange = t;
        }
      }

      if (params.has('host')) {
        state.hostFilter = params.get('host');
      }

      if (params.has('n')) {
        const n = parseInt(params.get('n'));
        if ([5, 10, 20, 50, 100].includes(n)) {
          state.topN = n;
        }
      }

      if (params.has('view') && params.get('view') === 'logs') {
        state.showLogs = true;
      }

      if (params.has('ts')) {
        const ts = new Date(params.get('ts'));
        if (!isNaN(ts.getTime())) {
          queryTimestamp = ts;
        }
      }

      if (params.has('filters')) {
        try {
          const filters = JSON.parse(params.get('filters'));
          if (Array.isArray(filters)) {
            state.filters = filters.filter(f => f.col && typeof f.value === 'string' && typeof f.exclude === 'boolean');
          }
        } catch (e) {
          console.error('Failed to parse filters from URL:', e);
        }
      }
    }

    function syncUIFromState() {
      timeRangeSelect.value = state.timeRange;
      topNSelect.value = state.topN;
      hostFilterInput.value = state.hostFilter;
      renderActiveFilters();

      if (state.showLogs) {
        logsView.classList.add('visible');
        dashboardContent.classList.add('hidden');
        logsBtn.classList.add('active');
        logsBtn.textContent = 'Dashboard';
      }
    }

    // DOM Elements
    const loginSection = document.getElementById('login');
    const dashboardSection = document.getElementById('dashboard');
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const timeRangeSelect = document.getElementById('timeRange');
    const topNSelect = document.getElementById('topN');
    const hostFilterInput = document.getElementById('hostFilter');
    const refreshBtn = document.getElementById('refreshBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const logsBtn = document.getElementById('logsBtn');
    const logsView = document.getElementById('logsView');
    const dashboardContent = document.getElementById('dashboardContent');

    // Initialize
    async function init() {
      // Load state from URL first
      loadStateFromURL();

      // Check for stored credentials and validate them
      const stored = localStorage.getItem('clickhouse_credentials');
      if (stored) {
        state.credentials = JSON.parse(stored);
        try {
          // Validate stored credentials before showing dashboard
          await query('SELECT 1', { skipCache: true });
          syncUIFromState();
          showDashboard();
          loadDashboard();
        } catch (err) {
          // Stored credentials are invalid, clear them and show login
          state.credentials = null;
          localStorage.removeItem('clickhouse_credentials');
          console.log('Stored credentials invalid, showing login');
        }
      }

      // Event listeners
      loginForm.addEventListener('submit', handleLogin);
      logoutBtn.addEventListener('click', handleLogout);
      refreshBtn.addEventListener('click', () => loadDashboard(true));
      timeRangeSelect.addEventListener('change', (e) => {
        state.timeRange = e.target.value;
        saveStateToURL();
        loadDashboard();
      });

      topNSelect.addEventListener('change', (e) => {
        state.topN = parseInt(e.target.value);
        saveStateToURL();
        loadAllBreakdowns();
      });

      let filterTimeout;
      hostFilterInput.addEventListener('input', (e) => {
        clearTimeout(filterTimeout);
        filterTimeout = setTimeout(() => {
          state.hostFilter = e.target.value;
          saveStateToURL();
          loadDashboard();
        }, 500);
      });

      // Logs button - click to toggle, hover when ready
      logsBtn.addEventListener('click', toggleLogsView);
      logsBtn.addEventListener('mouseenter', () => {
        if (state.logsReady && !state.showLogs) {
          toggleLogsView();
        }
      });
    }

    // Auth
    async function handleLogin(e) {
      e.preventDefault();
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;

      state.credentials = { user: username, password };

      try {
        // Test connection
        await query('SELECT 1');
        localStorage.setItem('clickhouse_credentials', JSON.stringify(state.credentials));
        loginError.classList.remove('visible');
        showDashboard();
        loadDashboard();
      } catch (err) {
        state.credentials = null;
        loginError.textContent = 'Authentication failed. Please check your credentials.';
        loginError.classList.add('visible');
      }
    }

    function handleLogout() {
      state.credentials = null;
      localStorage.removeItem('clickhouse_credentials');
      showLogin();
    }

    function showLogin() {
      loginSection.classList.remove('hidden');
      dashboardSection.classList.remove('visible');
    }

    function showDashboard() {
      loginSection.classList.add('hidden');
      dashboardSection.classList.add('visible');
    }

    // Query Helper
    async function query(sql, { cacheTtl = null, skipCache = false } = {}) {
      const params = new URLSearchParams();

      // Skip caching entirely for simple queries like auth check
      if (!skipCache) {
        // Short TTL (1s) when refresh button is clicked to bypass cache
        if (forceRefresh) {
          cacheTtl = 1;
        } else if (cacheTtl === null) {
          // Longer TTLs since we use fixed timestamps for deterministic queries
          // Cache is effectively invalidated by timestamp change on refresh/page load
          const ttls = {
            '1h': 300,     // 5 minutes for last hour
            '12h': 600,    // 10 minutes for last 12 hours
            '24h': 900,    // 15 minutes for last 24 hours
            '7d': 1800     // 30 minutes for last 7 days
          };
          cacheTtl = ttls[state.timeRange] || 300;
        }
        params.set('use_query_cache', '1');
        params.set('query_cache_ttl', cacheTtl.toString());
        params.set('query_cache_nondeterministic_function_handling', 'save');
      }

      // Normalize SQL whitespace for consistent cache keys
      const normalizedSql = sql.replace(/\s+/g, ' ').trim();

      const url = `${CLICKHOUSE_URL}?${params}`;
      const fetchStart = performance.now();
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': 'Basic ' + btoa(`${state.credentials.user}:${state.credentials.password}`)
        },
        body: normalizedSql + ' FORMAT JSON'
      });
      const fetchEnd = performance.now();

      if (!response.ok) {
        const text = await response.text();
        throw new Error(text);
      }

      const data = await response.json();
      // Wall clock timing from fetch call to response
      data._networkTime = fetchEnd - fetchStart;
      return data;
    }

    // Time range helpers
    function getInterval() {
      const intervals = {
        '1h': 'INTERVAL 1 HOUR',
        '12h': 'INTERVAL 12 HOUR',
        '24h': 'INTERVAL 24 HOUR',
        '7d': 'INTERVAL 7 DAY'
      };
      return intervals[state.timeRange];
    }

    function getTimeBucket() {
      const buckets = {
        '1h': 'toStartOfMinute',
        '12h': 'toStartOfTenMinutes',
        '24h': 'toStartOfFifteenMinutes',
        '7d': 'toStartOfHour'
      };
      return buckets[state.timeRange];
    }

    function getTimeFilter() {
      // Use fixed timestamp instead of now() for deterministic/cacheable queries
      const ts = queryTimestamp || new Date();
      // Format as 'YYYY-MM-DD HH:MM:SS' (no milliseconds)
      const isoTimestamp = ts.toISOString().replace('T', ' ').slice(0, 19);
      return `timestamp > toDateTime('${isoTimestamp}') - ${getInterval()}`;
    }

    function getHostFilter() {
      if (!state.hostFilter) return '';
      const escaped = state.hostFilter.replace(/'/g, "\\'");
      return `AND (\`request.host\` LIKE '%${escaped}%' OR \`request.headers.x_forwarded_host\` LIKE '%${escaped}%')`;
    }

    function buildFacetFilterSQL(filters) {
      if (filters.length === 0) return '';

      // Group filters by column
      const byColumn = {};
      for (const f of filters) {
        if (!byColumn[f.col]) byColumn[f.col] = { includes: [], excludes: [] };
        const escaped = f.value.replace(/'/g, "\\'");
        if (f.exclude) {
          byColumn[f.col].excludes.push(`${f.col} != '${escaped}'`);
        } else {
          byColumn[f.col].includes.push(`${f.col} = '${escaped}'`);
        }
      }

      // Build SQL for each column group
      const columnClauses = [];
      for (const col of Object.keys(byColumn)) {
        const { includes, excludes } = byColumn[col];
        const parts = [];
        // Include filters: OR together (match any of these values)
        if (includes.length > 0) {
          parts.push(includes.length === 1 ? includes[0] : `(${includes.join(' OR ')})`);
        }
        // Exclude filters: AND together (exclude all of these values)
        if (excludes.length > 0) {
          parts.push(excludes.join(' AND '));
        }
        // Combine includes and excludes for this column with AND
        columnClauses.push(parts.length === 1 ? parts[0] : `(${parts.join(' AND ')})`);
      }

      // Combine all column clauses with AND
      return columnClauses.map(c => `AND ${c}`).join(' ');
    }

    function getFacetFilters() {
      return buildFacetFilterSQL(state.filters);
    }

    function getFacetFiltersExcluding(col) {
      return buildFacetFilterSQL(state.filters.filter(f => f.col !== col));
    }

    function getFiltersForColumn(col) {
      return state.filters.filter(f => f.col === col);
    }

    function clearFiltersForColumn(col) {
      state.filters = state.filters.filter(f => f.col !== col);
      renderActiveFilters();
      saveStateToURL();
      loadDashboard();
    }

    function addFilter(col, value, exclude) {
      // Remove existing filter for same col+value
      state.filters = state.filters.filter(f => !(f.col === col && f.value === value));
      state.filters.push({ col, value, exclude });
      renderActiveFilters();
      saveStateToURL();
      loadDashboard();
    }

    function removeFilter(index) {
      state.filters.splice(index, 1);
      renderActiveFilters();
      saveStateToURL();
      loadDashboard();
    }

    function removeFilterByValue(col, value) {
      state.filters = state.filters.filter(f => !(f.col === col && f.value === value));
      renderActiveFilters();
      saveStateToURL();
      loadDashboard();
    }

    function renderActiveFilters() {
      const container = document.getElementById('activeFilters');
      if (state.filters.length === 0) {
        container.innerHTML = '';
        return;
      }
      container.innerHTML = state.filters.map((f, i) => {
        const label = f.exclude ? `NOT ${f.value}` : f.value;
        return `<span class="filter-tag ${f.exclude ? 'exclude' : ''}">${escapeHtml(label)}<button onclick="removeFilter(${i})">Ã—</button></span>`;
      }).join('');
    }

    // Format helpers
    function formatNumber(n) {
      if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
      if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
      return n.toString();
    }

    function formatBytes(bytes) {
      if (bytes >= 1e12) return (bytes / 1e12).toFixed(2) + ' TB';
      if (bytes >= 1e9) return (bytes / 1e9).toFixed(2) + ' GB';
      if (bytes >= 1e6) return (bytes / 1e6).toFixed(2) + ' MB';
      if (bytes >= 1e3) return (bytes / 1e3).toFixed(2) + ' KB';
      return bytes + ' B';
    }

    function formatPercent(current, previous) {
      if (!previous || previous === 0) return { text: '', className: '' };
      const change = ((current - previous) / previous) * 100;
      const sign = change >= 0 ? '+' : '';
      return {
        text: `${sign}${change.toFixed(1)}%`,
        className: change >= 0 ? 'positive' : 'negative'
      };
    }

    // Query timer
    let queryTimerInterval = null;
    let queryStartTime = null;
    const queryTimerEl = document.getElementById('queryTimer');

    // Track visible facets with IntersectionObserver
    const visibleFacets = new Set();
    const facetObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          visibleFacets.add(entry.target.id);
        } else {
          visibleFacets.delete(entry.target.id);
        }
      });
    }, { rootMargin: '50px' });

    // Check if element is in viewport
    function isInViewport(el) {
      const rect = el.getBoundingClientRect();
      return (
        rect.top < (window.innerHeight || document.documentElement.clientHeight) + 50 &&
        rect.bottom > -50 &&
        rect.left < (window.innerWidth || document.documentElement.clientWidth) + 50 &&
        rect.right > -50
      );
    }

    // Observe all breakdown cards and check initial visibility
    document.querySelectorAll('.breakdown-card').forEach(card => {
      facetObserver.observe(card);
      // Check initial visibility for elements already in viewport
      if (isInViewport(card)) {
        visibleFacets.add(card.id);
      }
    });

    function getTimerClass(ms) {
      if (ms < 1000) return 'query-timer fast';
      if (ms < 10000) return 'query-timer medium';
      return 'query-timer slow';
    }

    function startQueryTimer() {
      queryStartTime = performance.now();
      if (queryTimerInterval) clearInterval(queryTimerInterval);
      queryTimerInterval = setInterval(() => {
        const elapsed = performance.now() - queryStartTime;
        queryTimerEl.textContent = formatQueryTime(elapsed);
        queryTimerEl.className = getTimerClass(elapsed);
      }, 10);
    }

    function stopQueryTimer() {
      if (!queryTimerInterval) return; // Already stopped
      clearInterval(queryTimerInterval);
      queryTimerInterval = null;
      const elapsed = performance.now() - queryStartTime;
      queryTimerEl.textContent = formatQueryTime(elapsed);
      queryTimerEl.className = getTimerClass(elapsed);
    }

    function formatQueryTime(ms) {
      if (ms < 1000) return `${Math.round(ms)}ms`;
      return `${(ms / 1000).toFixed(2)}s`;
    }

    // Load Dashboard Data
    let forceRefresh = false;
    let queryTimestamp = null;
    let facetTimings = {}; // Track elapsed time per facet id

    // Mark the slowest facet with a glow
    function markSlowestFacet() {
      // Remove existing slowest markers
      document.querySelectorAll('.speed-indicator.slowest').forEach(el => {
        el.classList.remove('slowest');
      });

      // Find the slowest facet
      let slowestId = null;
      let slowestTime = 0;
      for (const [id, time] of Object.entries(facetTimings)) {
        if (time > slowestTime) {
          slowestTime = time;
          slowestId = id;
        }
      }

      // Add slowest class to the indicator
      if (slowestId) {
        const card = document.getElementById(slowestId);
        const indicator = card?.querySelector('.speed-indicator');
        if (indicator) {
          indicator.classList.add('slowest');
        }
      }
    }

    // Check if any visible facet is still updating
    function hasVisibleUpdatingFacets() {
      for (const id of visibleFacets) {
        const card = document.getElementById(id);
        if (card && card.classList.contains('updating')) {
          return true;
        }
      }
      return false;
    }

    async function loadDashboard(refresh = false) {
      forceRefresh = refresh;
      // Only set new timestamp if not already set from URL or if refreshing
      if (!queryTimestamp || refresh) {
        queryTimestamp = new Date();
      }
      saveStateToURL();
      startQueryTimer();
      facetTimings = {}; // Reset timings for this load

      const timeFilter = getTimeFilter();
      const hostFilter = getHostFilter();

      // Start loading time series
      const timeSeriesPromise = loadTimeSeries();

      // Start loading all facets in parallel (they manage their own blur state)
      const facetPromises = allBreakdowns.map(b =>
        loadBreakdown(b, timeFilter, hostFilter).then(() => {
          // After each facet completes, check if timer should stop
          if (!hasVisibleUpdatingFacets()) {
            stopQueryTimer();
          }
        })
      );

      // Wait for all facets to complete, then mark slowest
      Promise.all(facetPromises).then(() => {
        markSlowestFacet();
      });

      // Wait for time series to complete
      await timeSeriesPromise;

      // If no visible facets are updating after time series, stop timer
      if (!hasVisibleUpdatingFacets()) {
        stopQueryTimer();
      }

      // Load logs in background
      loadLogs();

      forceRefresh = false;
    }

    // Time Series Chart
    async function loadTimeSeries() {
      const timeFilter = getTimeFilter();
      const hostFilter = getHostFilter();
      const facetFilters = getFacetFilters();
      const bucket = getTimeBucket();

      const sql = `
        SELECT
          ${bucket}(timestamp) as t,
          countIf(\`response.status\` >= 100 AND \`response.status\` < 400) as cnt_ok,
          countIf(\`response.status\` >= 400 AND \`response.status\` < 500) as cnt_4xx,
          countIf(\`response.status\` >= 500) as cnt_5xx
        FROM ${DATABASE}.${TABLE}
        WHERE ${timeFilter} ${hostFilter} ${facetFilters}
        GROUP BY t
        ORDER BY t
      `;

      try {
        const result = await query(sql);
        renderChart(result.data);
      } catch (err) {
        console.error('Chart error:', err);
      }
    }

    function renderChart(data) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;

      // Set canvas size
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 20, right: 20, bottom: 40, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Clear
      ctx.clearRect(0, 0, width, height);

      // Get CSS variables for theming
      const styles = getComputedStyle(document.documentElement);
      const cssVar = (name) => styles.getPropertyValue(name).trim();

      if (data.length === 0) {
        ctx.fillStyle = cssVar('--text-secondary');
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }

      // Parse data into stacked values
      const series = {
        ok: data.map(d => parseInt(d.cnt_ok) || 0),
        client: data.map(d => parseInt(d.cnt_4xx) || 0),
        server: data.map(d => parseInt(d.cnt_5xx) || 0)
      };

      // Calculate stacked totals for max value
      const totals = data.map((_, i) => series.ok[i] + series.client[i] + series.server[i]);
      const maxValue = Math.max(...totals);
      const minValue = 0;

      // Colors from CSS variables
      const hexToRgba = (hex, alpha) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };

      const okColor = cssVar('--status-ok');
      const clientColor = cssVar('--status-client-error');
      const serverColor = cssVar('--status-server-error');

      const colors = {
        ok: { line: okColor, fill: hexToRgba(okColor, 0.3) },
        client: { line: clientColor, fill: hexToRgba(clientColor, 0.3) },
        server: { line: serverColor, fill: hexToRgba(serverColor, 0.3) }
      };

      // Draw axes
      ctx.strokeStyle = cssVar('--axis-line');
      ctx.lineWidth = 1;

      // Y axis
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.stroke();

      // X axis
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Y axis labels
      ctx.fillStyle = cssVar('--text-secondary');
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 4; i++) {
        const val = minValue + (maxValue - minValue) * (i / 4);
        const y = height - padding.bottom - (chartHeight * i / 4);
        ctx.fillText(formatNumber(Math.round(val)), padding.left - 8, y + 4);

        // Grid line
        ctx.strokeStyle = cssVar('--grid-line');
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // X axis labels
      ctx.fillStyle = cssVar('--text-secondary');
      ctx.textAlign = 'center';
      const labelStep = Math.ceil(data.length / 6);
      for (let i = 0; i < data.length; i += labelStep) {
        const x = padding.left + (chartWidth * i / (data.length - 1));
        const time = new Date(data[i].t);
        const label = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' });
        ctx.fillText(label, x, height - padding.bottom + 20);
      }

      // Helper function to get Y coordinate
      const getY = (value) => height - padding.bottom - (chartHeight * value / (maxValue || 1));
      const getX = (i) => padding.left + (chartWidth * i / (data.length - 1 || 1));

      // Draw stacked areas (bottom to top: server, client, ok)
      // Reversed order: 5xx at bottom, then 4xx, then 1xx-3xx on top

      // Calculate cumulative values for stacking (reversed order)
      const stackedServer = series.server.slice();
      const stackedClient = series.server.map((v, i) => v + series.client[i]);
      const stackedOk = series.server.map((v, i) => v + series.client[i] + series.ok[i]);

      // Draw 1xx-3xx area (top layer - green)
      if (series.ok.some(v => v > 0)) {
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(stackedClient[0]));
        for (let i = 0; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedOk[i]));
        }
        for (let i = data.length - 1; i >= 0; i--) {
          ctx.lineTo(getX(i), getY(stackedClient[i]));
        }
        ctx.closePath();
        ctx.fillStyle = colors.ok.fill;
        ctx.fill();

        // Draw line on top
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(stackedOk[0]));
        for (let i = 1; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedOk[i]));
        }
        ctx.strokeStyle = colors.ok.line;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Draw 4xx area (middle layer - yellow/orange)
      if (series.client.some(v => v > 0)) {
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(stackedServer[0]));
        for (let i = 0; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedClient[i]));
        }
        for (let i = data.length - 1; i >= 0; i--) {
          ctx.lineTo(getX(i), getY(stackedServer[i]));
        }
        ctx.closePath();
        ctx.fillStyle = colors.client.fill;
        ctx.fill();

        // Draw line on top
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(stackedClient[0]));
        for (let i = 1; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedClient[i]));
        }
        ctx.strokeStyle = colors.client.line;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Draw 5xx area (bottom layer - red)
      if (series.server.some(v => v > 0)) {
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(0));
        for (let i = 0; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedServer[i]));
        }
        ctx.lineTo(getX(data.length - 1), getY(0));
        ctx.closePath();
        ctx.fillStyle = colors.server.fill;
        ctx.fill();

        // Draw line on top
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(stackedServer[0]));
        for (let i = 1; i < data.length; i++) {
          ctx.lineTo(getX(i), getY(stackedServer[i]));
        }
        ctx.strokeStyle = colors.server.line;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // Link generation helpers
    function hostLink(val) {
      if (!val) return null;
      return 'https://' + val;
    }

    function forwardedHostLink(val) {
      if (!val) return null;
      // Take first host if comma-separated
      const firstHost = val.split(',')[0].trim();
      return 'https://' + firstHost;
    }

    function refererLink(val) {
      if (!val) return null;
      // Referer is already a full URL
      if (val.startsWith('http://') || val.startsWith('https://')) {
        return val;
      }
      return null;
    }

    function pathLink(val) {
      if (!val) return null;
      // Only link if we have an active host filter
      const hostFilter = state.filters.find(f => f.col === '`request.host`' && !f.exclude);
      if (hostFilter) {
        return 'https://' + hostFilter.value + val;
      }
      return null;
    }

    // Breakdown Tables
    const allBreakdowns = [
      { id: 'breakdown-status-range', col: "concat(toString(intDiv(`response.status`, 100)), 'xx')" },
      { id: 'breakdown-hosts', col: '`request.host`', linkFn: hostLink },
      { id: 'breakdown-forwarded-hosts', col: '`request.headers.x_forwarded_host`', linkFn: forwardedHostLink },
      { id: 'breakdown-content-types', col: '`response.headers.content_type`' },
      { id: 'breakdown-status', col: 'toString(`response.status`)' },
      { id: 'breakdown-errors', col: '`response.headers.x_error`', extraFilter: "AND `response.headers.x_error` != ''" },
      { id: 'breakdown-cache', col: 'upper(`cdn.cache_status`)' },
      { id: 'breakdown-paths', col: '`request.url`', linkFn: pathLink },
      { id: 'breakdown-referers', col: '`request.headers.referer`', linkFn: refererLink },
      { id: 'breakdown-user-agents', col: '`request.headers.user_agent`' },
      { id: 'breakdown-ips', col: "if(`request.headers.x_forwarded_for` != '', `request.headers.x_forwarded_for`, `client.ip`)", linkPrefix: 'https://centralops.net/co/DomainDossier?dom_whois=1&net_whois=1&addr=' },
      { id: 'breakdown-request-type', col: '`helix.request_type`', extraFilter: "AND `helix.request_type` != ''" },
      { id: 'breakdown-backend-type', col: '`helix.backend_type`', extraFilter: "AND `helix.backend_type` != ''" },
      { id: 'breakdown-methods', col: '`request.method`' },
      { id: 'breakdown-datacenters', col: '`cdn.datacenter`' },
      { id: 'breakdown-asn', col: "concat(toString(`client.asn`), ' - ', `client.name`)", extraFilter: "AND `client.asn` != 0", linkPrefix: 'https://mxtoolbox.com/SuperTool.aspx?action=asn%3aAS', linkSuffix: '&run=toolpage' }
    ];

    async function loadAllBreakdowns() {
      const timeFilter = getTimeFilter();
      const hostFilter = getHostFilter();
      await Promise.all(allBreakdowns.map(b => loadBreakdown(b, timeFilter, hostFilter)));
    }

    async function loadBreakdown(b, timeFilter, hostFilter) {
      const card = document.getElementById(b.id);
      card.classList.add('updating');

      const extra = b.extraFilter || '';
      // Get filters excluding this facet's column to show all values for active facets
      const facetFilters = getFacetFiltersExcluding(b.col);
      const sql = `
        SELECT
          ${b.col} as dim,
          count() as cnt,
          countIf(\`response.status\` >= 100 AND \`response.status\` < 400) as cnt_ok,
          countIf(\`response.status\` >= 400 AND \`response.status\` < 500) as cnt_4xx,
          countIf(\`response.status\` >= 500) as cnt_5xx
        FROM ${DATABASE}.${TABLE}
        WHERE ${timeFilter} ${hostFilter} ${facetFilters} ${extra}
        GROUP BY dim
        ORDER BY cnt DESC
        LIMIT ${state.topN}
      `;

      const startTime = performance.now();
      try {
        const result = await query(sql);
        // Prefer actual network time from Resource Timing API, fallback to wall clock
        const elapsed = result._networkTime ?? (performance.now() - startTime);
        facetTimings[b.id] = elapsed; // Track timing for slowest detection
        renderBreakdownTable(b.id, result.data, b.col, b.linkPrefix, b.linkSuffix, b.linkFn, elapsed);
      } catch (err) {
        console.error(`Breakdown error (${b.id}):`, err);
        renderBreakdownError(b.id, err.message);
      } finally {
        card.classList.remove('updating');
      }
    }

    function renderBreakdownTable(id, data, col, linkPrefix, linkSuffix, linkFn, elapsed) {
      const card = document.getElementById(id);
      // Store original title in data attribute, or read from h3 if first render
      if (!card.dataset.title) {
        card.dataset.title = card.querySelector('h3').textContent;
      }
      const title = card.dataset.title;

      // Get active filters for this column
      const columnFilters = getFiltersForColumn(col);
      const hasFilters = columnFilters.length > 0;
      const colEscaped = col.replace(/'/g, "\\'");

      // Speed indicator based on elapsed time
      const speedClass = elapsed < 1000 ? 'fast' : (elapsed < 10000 ? 'medium' : 'slow');
      const speedTitle = formatQueryTime(elapsed);
      const speedIndicator = `<span class="speed-indicator ${speedClass}" title="${speedTitle}"></span>`;

      if (data.length === 0) {
        let html = `<h3>${speedIndicator}${title}`;
        if (hasFilters) {
          html += ` <button class="clear-facet-btn" onclick="clearFiltersForColumn('${colEscaped}')">Clear</button>`;
        }
        html += `</h3><div class="empty">No data</div>`;
        card.innerHTML = html;
        return;
      }

      const maxCount = Math.max(...data.map(d => parseInt(d.cnt)));
      const total = data.reduce((sum, d) => sum + parseInt(d.cnt), 0);

      let html = `<h3>${speedIndicator}${title}`;
      if (hasFilters) {
        html += ` <button class="clear-facet-btn" onclick="clearFiltersForColumn('${colEscaped}')">Clear</button>`;
      }
      html += `</h3><table class="breakdown-table">`;

      for (const row of data) {
        const cnt = parseInt(row.cnt);
        const cntOk = parseInt(row.cnt_ok) || 0;
        const cnt4xx = parseInt(row.cnt_4xx) || 0;
        const cnt5xx = parseInt(row.cnt_5xx) || 0;

        // Calculate percentages relative to max count (for bar width)
        const barWidth = (cnt / maxCount) * 100;
        // Calculate percentages within this row (for stacked segments)
        const pct5xx = cnt > 0 ? (cnt5xx / cnt) * 100 : 0;
        const pct4xx = cnt > 0 ? (cnt4xx / cnt) * 100 : 0;
        const pctOk = cnt > 0 ? (cntOk / cnt) * 100 : 0;

        const dim = row.dim || '(empty)';
        const dimEscaped = (row.dim || '').replace(/'/g, "\\'").replace(/\\/g, '\\\\');

        // Check if this value is currently filtered
        const activeFilter = columnFilters.find(f => f.value === (row.dim || ''));
        const isIncluded = activeFilter && !activeFilter.exclude;
        const isExcluded = activeFilter && activeFilter.exclude;
        const rowClass = isIncluded ? 'filter-included' : (isExcluded ? 'filter-excluded' : '');

        // Build dimension cell content - with optional link
        let dimContent;
        let linkUrl = null;
        if (linkFn && row.dim) {
          linkUrl = linkFn(row.dim);
        } else if (linkPrefix && row.dim) {
          // For ASN links, extract just the number (before " - ")
          const linkValue = row.dim.includes(' - ') ? row.dim.split(' - ')[0] : row.dim;
          linkUrl = linkPrefix + linkValue + (linkSuffix || '');
        }
        if (linkUrl) {
          dimContent = `<a href="${linkUrl}" target="_blank" rel="noopener">${escapeHtml(dim)}</a>`;
        } else {
          dimContent = escapeHtml(dim);
        }

        // Determine button actions based on current filter state
        const filterBtn = isIncluded
          ? `<button class="action-btn" onclick="removeFilterByValue('${colEscaped}', '${dimEscaped}')">Clear</button>`
          : `<button class="action-btn" onclick="addFilter('${colEscaped}', '${dimEscaped}', false)">Filter</button>`;
        const excludeBtn = isExcluded
          ? `<button class="action-btn" onclick="removeFilterByValue('${colEscaped}', '${dimEscaped}')">Clear</button>`
          : `<button class="action-btn exclude" onclick="addFilter('${colEscaped}', '${dimEscaped}', true)">Exclude</button>`;

        html += `
          <tr class="${rowClass}">
            <td class="dim" title="${escapeHtml(dim)}">${dimContent}</td>
            <td class="count">
              <span class="value">${formatNumber(cnt)}</span>
              ${filterBtn}
            </td>
            <td class="bar">
              <div class="bar-inner" style="width: ${barWidth}%">
                <div class="bar-segment bar-5xx" style="width: ${pct5xx}%"></div>
                <div class="bar-segment bar-4xx" style="width: ${pct4xx}%"></div>
                <div class="bar-segment bar-ok" style="width: ${pctOk}%"></div>
              </div>
              ${excludeBtn}
            </td>
          </tr>
        `;
      }
      html += '</table>';
      card.innerHTML = html;
    }

    function renderBreakdownError(id, message) {
      const card = document.getElementById(id);
      const title = card.querySelector('h3').textContent;
      card.innerHTML = `<h3>${title}</h3><div class="empty">Error loading data</div>`;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Logs View
    function toggleLogsView() {
      state.showLogs = !state.showLogs;
      if (state.showLogs) {
        logsView.classList.add('visible');
        dashboardContent.classList.add('hidden');
        logsBtn.classList.add('active');
        logsBtn.textContent = 'Dashboard';
      } else {
        logsView.classList.remove('visible');
        dashboardContent.classList.remove('hidden');
        logsBtn.classList.remove('active');
        logsBtn.textContent = 'Logs';
      }
      saveStateToURL();
    }

    async function loadLogs() {
      if (state.logsLoading) return;
      state.logsLoading = true;
      state.logsReady = false;
      logsBtn.classList.remove('ready');

      const timeFilter = getTimeFilter();
      const hostFilter = getHostFilter();
      const facetFilters = getFacetFilters();

      const sql = `
        SELECT *
        FROM ${DATABASE}.${TABLE}
        WHERE ${timeFilter} ${hostFilter} ${facetFilters}
        ORDER BY timestamp DESC
        LIMIT 100
      `;

      try {
        const result = await query(sql);
        state.logsData = result.data;
        renderLogsTable(result.data);
        state.logsReady = true;
        logsBtn.classList.add('ready');
      } catch (err) {
        console.error('Logs error:', err);
        renderLogsError(err.message);
      } finally {
        state.logsLoading = false;
      }
    }

    function renderLogsTable(data) {
      const container = logsView.querySelector('.logs-table-container');

      if (data.length === 0) {
        container.innerHTML = '<div class="empty" style="padding: 60px;">No logs matching current filters</div>';
        return;
      }

      // Get all column names from first row
      const columns = Object.keys(data[0]);

      let html = `
        <table class="logs-table">
          <thead>
            <tr>
              ${columns.map(col => `<th>${escapeHtml(col)}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
      `;

      for (const row of data) {
        html += '<tr>';
        for (const col of columns) {
          let value = row[col];
          let cellClass = '';
          let displayValue = '';

          // Format specific columns
          if (col === 'timestamp' && value) {
            displayValue = new Date(value).toLocaleString();
            cellClass = 'timestamp';
          } else if (col === 'response.status' && value) {
            const status = parseInt(value);
            displayValue = String(status);
            if (status >= 500) cellClass = 'status-5xx';
            else if (status >= 400) cellClass = 'status-4xx';
            else cellClass = 'status-ok';
          } else if (col === 'response.body_size' && value) {
            displayValue = formatBytes(parseInt(value));
          } else if (col === 'request.method') {
            displayValue = value || '';
            cellClass = 'method';
          } else if (value === null || value === undefined || value === '') {
            displayValue = '';
          } else if (typeof value === 'object') {
            displayValue = JSON.stringify(value);
          } else {
            displayValue = String(value);
          }

          const escaped = escapeHtml(displayValue);
          html += `<td class="${cellClass}" title="${escaped}">${escaped}</td>`;
        }
        html += '</tr>';
      }

      html += '</tbody></table>';
      container.innerHTML = html;
    }

    function renderLogsError(message) {
      const container = logsView.querySelector('.logs-table-container');
      container.innerHTML = `<div class="empty" style="padding: 60px;">Error loading logs: ${escapeHtml(message)}</div>`;
    }

    // Start
    init();
  </script>
</body>
</html>
